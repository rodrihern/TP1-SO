<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>master.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">//Habilita funcionalidades POSIX (p. ej. clock_gettime, pselect, etc.) según el estándar 2008.</a>
<a name="ln2">#define _POSIX_C_SOURCE 200809L</a>
<a name="ln3"></a>
<a name="ln4">#include &lt;stdio.h&gt;</a>
<a name="ln5">#include &lt;stdlib.h&gt;</a>
<a name="ln6">#include &lt;string.h&gt;</a>
<a name="ln7">#include &lt;time.h&gt;</a>
<a name="ln8">#include &lt;unistd.h&gt;</a>
<a name="ln9">#include &lt;fcntl.h&gt;</a>
<a name="ln10">#include &lt;sys/mman.h&gt;</a>
<a name="ln11">#include &lt;sys/stat.h&gt;</a>
<a name="ln12">#include &lt;sys/wait.h&gt;</a>
<a name="ln13">#include &lt;sys/select.h&gt;</a>
<a name="ln14">#include &lt;errno.h&gt;</a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16"></a>
<a name="ln17">#include &quot;common.h&quot;</a>
<a name="ln18">#include &quot;shm.h&quot;</a>
<a name="ln19">#include &quot;reader_sync.h&quot;</a>
<a name="ln20">#include &quot;writer_sync.h&quot;</a>
<a name="ln21"></a>
<a name="ln22"></a>
<a name="ln23">static void die(const char *m, int error_code) { </a>
<a name="ln24">    perror(m); </a>
<a name="ln25">    exit(error_code); </a>
<a name="ln26">}</a>
<a name="ln27"></a>
<a name="ln28">/**</a>
<a name="ln29"> * Limita el valor 'v' para que esté dentro del rango [lo, hi].</a>
<a name="ln30"> * Si 'v' es menor que 'lo', retorna 'lo'.</a>
<a name="ln31"> * Si 'v' es mayor que 'hi', retorna 'hi'.</a>
<a name="ln32"> * Si 'v' está en el rango, retorna 'v'.</a>
<a name="ln33"> */</a>
<a name="ln34">static int clamp(int v,int lo,int hi) { </a>
<a name="ln35">    return v &lt; lo ? lo : (v &gt; hi ? hi : v); </a>
<a name="ln36">}</a>
<a name="ln37"></a>
<a name="ln38">// Usa la semilla para inicializar el tablero con números aleatorios</a>
<a name="ln39">static void init_board(game_state_t *gs, unsigned seed) {</a>
<a name="ln40">    srand(seed);</a>
<a name="ln41">    for(int y=0;y&lt;gs-&gt;board_height;y++)</a>
<a name="ln42">        for(int x=0;x&lt;gs-&gt;board_width;x++)</a>
<a name="ln43">            gs-&gt;board[idx(x,y,gs-&gt;board_width)] = (rand()%(MAX_REWARD-MIN_REWARD+1))+MIN_REWARD;</a>
<a name="ln44">}</a>
<a name="ln45"></a>
<a name="ln46">static void place_players(game_state_t *gs){</a>
<a name="ln47">    int W=gs-&gt;board_width, H=gs-&gt;board_height, P=(int)gs-&gt;num_players;</a>
<a name="ln48">    for(int i=0;i&lt;P;i++){</a>
<a name="ln49">        int x = (i+1)*W/(P+1);</a>
<a name="ln50">        int y = (i%2? H/3 : (2*H)/3);</a>
<a name="ln51">        gs-&gt;players[i].x = (unsigned short)clamp(x,0,W-1);</a>
<a name="ln52">        gs-&gt;players[i].y = (unsigned short)clamp(y,0,H-1);</a>
<a name="ln53">        gs-&gt;players[i].score=0;</a>
<a name="ln54">        gs-&gt;players[i].valid_moves=0;</a>
<a name="ln55">        gs-&gt;players[i].invalid_moves=0;</a>
<a name="ln56">        gs-&gt;players[i].is_blocked=false;</a>
<a name="ln57">        snprintf(gs-&gt;players[i].name, MAX_NAME_LEN, &quot;P%d&quot;, i);</a>
<a name="ln58">    // Las celdas iniciales NO otorgan recompensa: marcarlas como capturadas por el jugador</a>
<a name="ln59">    // Usamos el mismo esquema de encoding que durante el juego</a>
<a name="ln60">    gs-&gt;board[idx(gs-&gt;players[i].x, gs-&gt;players[i].y, W)] = player_to_cell_value(i);</a>
<a name="ln61">    }</a>
<a name="ln62">}</a>
<a name="ln63"></a>
<a name="ln64">static int apply_move(game_state_t *gs, int pid_idx, unsigned char dir){</a>
<a name="ln65">    if(!is_valid_direction(dir)){ gs-&gt;players[pid_idx].invalid_moves++; return 0; }</a>
<a name="ln66">    int dx,dy; get_direction_offset((direction_t)dir, &amp;dx, &amp;dy);</a>
<a name="ln67">    int W=gs-&gt;board_width, H=gs-&gt;board_height;</a>
<a name="ln68">    int nx = (int)gs-&gt;players[pid_idx].x + dx;</a>
<a name="ln69">    int ny = (int)gs-&gt;players[pid_idx].y + dy;</a>
<a name="ln70">    if (!is_inside(nx,ny,W,H)) { </a>
<a name="ln71">        gs-&gt;players[pid_idx].invalid_moves++; </a>
<a name="ln72">        return 0; </a>
<a name="ln73">    }</a>
<a name="ln74"></a>
<a name="ln75">    int *cell = &amp;gs-&gt;board[idx(nx,ny,W)];</a>
<a name="ln76">    if (!cell_is_free(*cell)) { </a>
<a name="ln77">        gs-&gt;players[pid_idx].invalid_moves++; </a>
<a name="ln78">        return 0; </a>
<a name="ln79">    }</a>
<a name="ln80"></a>
<a name="ln81">    gs-&gt;players[pid_idx].x = (unsigned short)nx;</a>
<a name="ln82">    gs-&gt;players[pid_idx].y = (unsigned short)ny;</a>
<a name="ln83">    gs-&gt;players[pid_idx].score += (unsigned)*cell;</a>
<a name="ln84">    gs-&gt;players[pid_idx].valid_moves++;</a>
<a name="ln85">    *cell = player_to_cell_value(pid_idx); // capturada por idx (valor negativo)</a>
<a name="ln86">    return 1;</a>
<a name="ln87">}</a>
<a name="ln88"></a>
<a name="ln89">static void exec_with_board_args(const char *bin, int board_width, int board_height, const char *error_msg) {</a>
<a name="ln90">    char wb[16], hb[16];</a>
<a name="ln91">    snprintf(wb, sizeof wb, &quot;%d&quot;, board_width);</a>
<a name="ln92">    snprintf(hb, sizeof hb, &quot;%d&quot;, board_height);</a>
<a name="ln93">    execl(bin, bin, wb, hb, (char*)NULL);</a>
<a name="ln94">    perror(error_msg);</a>
<a name="ln95">    _exit(EXEC_ERROR_CODE);</a>
<a name="ln96">}</a>
<a name="ln97"></a>
<a name="ln98">/* ----------------------------- main ------------------------------- */</a>
<a name="ln99">typedef struct { </a>
<a name="ln100">    int read_fd; // read fd (extremo de lectura del pipe)</a>
<a name="ln101">    int write_fd; // write fd (extremo de escritura del pipe)</a>
<a name="ln102">    pid_t pid; // pid del proceso hijo</a>
<a name="ln103">    int alive; // indica si el proceso hijo está vivo</a>
<a name="ln104">} pipe_info_t;</a>
<a name="ln105"></a>
<a name="ln106">int main(int argc, char **argv){</a>
<a name="ln107">    // Inicializo con valores por defecto</a>
<a name="ln108">    int board_width=MIN_BOARD_SIZE, board_height=MIN_BOARD_SIZE, delay_ms=DEFAULT_DELAY_MS, timeout_s=DEFAULT_TIMEOUT_S;</a>
<a name="ln109">    unsigned seed=(unsigned)time(NULL); </a>
<a name="ln110">    const char *view_bin=NULL;</a>
<a name="ln111">    char* player_bins[MAX_PLAYERS]; </a>
<a name="ln112">    int num_players=0;</a>
<a name="ln113"></a>
<a name="ln114">    // Parseo de los argumentos de la línea de comandos</a>
<a name="ln115">    for (int i=1;i&lt;argc;i++){</a>
<a name="ln116">        if (!strcmp(argv[i],&quot;-w&quot;) &amp;&amp; argc&gt;i+1) </a>
<a name="ln117">            board_width=atoi(argv[++i]);</a>
<a name="ln118">        else if (!strcmp(argv[i],&quot;-h&quot;) &amp;&amp; argc&gt;i+1) </a>
<a name="ln119">            board_height=atoi(argv[++i]); </a>
<a name="ln120">        else if (!strcmp(argv[i],&quot;-d&quot;) &amp;&amp; argc&gt;i+1) </a>
<a name="ln121">            delay_ms=atoi(argv[++i]);</a>
<a name="ln122">        else if (!strcmp(argv[i],&quot;-t&quot;) &amp;&amp; argc&gt;i+1) </a>
<a name="ln123">            timeout_s=atoi(argv[++i]);</a>
<a name="ln124">        else if (!strcmp(argv[i],&quot;-s&quot;) &amp;&amp; argc&gt;i+1) </a>
<a name="ln125">            seed=(unsigned)atoi(argv[++i]);</a>
<a name="ln126">        else if (!strcmp(argv[i],&quot;-v&quot;) &amp;&amp; argc&gt;i+1) </a>
<a name="ln127">            view_bin=argv[++i];</a>
<a name="ln128">        else if (!strcmp(argv[i],&quot;-p&quot;)){</a>
<a name="ln129">            while (argc&gt;i+1 &amp;&amp; num_players&lt;MAX_PLAYERS &amp;&amp; argv[i+1][0]!='-') </a>
<a name="ln130">                player_bins[num_players++]=argv[++i];</a>
<a name="ln131">        } </a>
<a name="ln132">        else { </a>
<a name="ln133">            die(&quot;Usage: ./master [-w width] [-h height] [-d delay] [-s seed] [-v view] [-t timeout] -p player1 player2...&quot;, ERROR_INVALID_ARGS);</a>
<a name="ln134">        } // CHICOS REVISEMOS ESTO</a>
<a name="ln135">    }</a>
<a name="ln136"></a>
<a name="ln137">    // Validaciones del tamaño del tablero</a>
<a name="ln138">    board_width = clamp(board_width, MIN_BOARD_SIZE, MAX_BOARD_SIZE);</a>
<a name="ln139">    board_height = clamp(board_height, MIN_BOARD_SIZE, MAX_BOARD_SIZE);</a>
<a name="ln140">    if (num_players&lt;1){ </a>
<a name="ln141">        die(&quot;Error: At least one playermust be specified using -p\n&quot;, ERROR_INVALID_ARGS);</a>
<a name="ln142">    }</a>
<a name="ln143"></a>
<a name="ln144">    // SHM: abrir/crear</a>
<a name="ln145">    shm_adt game_state_shm, game_sync_shm;</a>
<a name="ln146">    if (shm_region_open(&amp;game_state_shm, SHM_STATE, game_state_size(board_width,board_height)) == -1) </a>
<a name="ln147">        die(&quot;Error: failed to open or create shared memory region for game state&quot;, ERROR_SHM);</a>
<a name="ln148">    if (shm_region_open(&amp;game_sync_shm,  SHM_SYNC, sizeof(game_sync_t)) == -1) </a>
<a name="ln149">        die(&quot;Error: failed to open or create shared memory region for game sync&quot;, ERROR_SHM);</a>
<a name="ln150"></a>
<a name="ln151">    game_state_t *gs=NULL; </a>
<a name="ln152">    game_sync_t *sync=NULL;</a>
<a name="ln153">    if (game_state_map(game_state_shm, (unsigned short)board_width, (unsigned short)board_height, &amp;gs) == -1) </a>
<a name="ln154">        die(&quot;Error: failed to map game state shared memory&quot;, ERROR_SHM);</a>
<a name="ln155">    if (game_sync_map(game_sync_shm, &amp;sync) == -1) </a>
<a name="ln156">        die(&quot;Error: failed to map game sync shared memory&quot;, ERROR_SHM);</a>
<a name="ln157"></a>
<a name="ln158">    // inicialización de estado </a>
<a name="ln159">    writer_enter(sync);</a>
<a name="ln160">    gs-&gt;board_width = (unsigned short) board_width;</a>
<a name="ln161">    gs-&gt;board_height = (unsigned short) board_height;</a>
<a name="ln162">    gs-&gt;num_players = (unsigned) num_players;</a>
<a name="ln163">    gs-&gt;game_finished = false;</a>
<a name="ln164">    init_board(gs, seed);</a>
<a name="ln165">    place_players(gs);</a>
<a name="ln166">    writer_exit(sync);</a>
<a name="ln167"></a>
<a name="ln168">    // pipes &amp; fork jugadores </a>
<a name="ln169">    pipe_info_t pipes[MAX_PLAYERS] = {0};</a>
<a name="ln170">    for (int i=0;i&lt;num_players;i++){</a>
<a name="ln171">        int fds[2]; </a>
<a name="ln172">        if (pipe(fds)==-1) </a>
<a name="ln173">            die(&quot;Error: could not create pipe for player process&quot;, ERROR_PIPE);</a>
<a name="ln174">        pipes[i].read_fd = fds[0]; </a>
<a name="ln175">        pipes[i].write_fd = fds[1]; </a>
<a name="ln176">        pipes[i].alive=1;</a>
<a name="ln177">        fcntl(pipes[i].read_fd, F_SETFL, O_NONBLOCK); // Habilitar modo no bloqueante en el extremo de lectura. </a>
<a name="ln178">        // Así, las operaciones de lectura (read) sobre ese pipe no se detendrán esperando datos; si no hay datos, retornan inmediatamente con error EAGAIN</a>
<a name="ln179">        // Así el master puede seguir funcionando aunque un jugador no envíe datos</a>
<a name="ln180"></a>
<a name="ln181">        pid_t pid = fork();</a>
<a name="ln182">        if (pid &lt; 0) // Hubo un error</a>
<a name="ln183">            die(&quot;Error: could not fork player process&quot;, ERROR_FORK);</a>
<a name="ln184">        if (pid == 0){ // Estoy en el proceso hijo</a>
<a name="ln185">            // hijo jugador: dup write-end -&gt; fd=1 </a>
<a name="ln186">            dup2(pipes[i].write_fd, 1); // Redirige el extremo de escritura del pipe al stdout (fd=1). Así, todo lo que el jugador escriba por printf va al pipe.</a>
<a name="ln187">            close(pipes[i].read_fd);  // Cierra el extremo de lectura del pipe (el hijo no lee el pipe)</a>
<a name="ln188">            // argv: width height </a>
<a name="ln189">            exec_with_board_args(player_bins[i], board_width, board_height, &quot;exec player&quot;);</a>
<a name="ln190">        } else { // Estoy en el proceso padre</a>
<a name="ln191">            close(pipes[i].write_fd); // master no escribe</a>
<a name="ln192">            pipes[i].pid = pid;</a>
<a name="ln193">            writer_enter(sync);</a>
<a name="ln194">            gs-&gt;players[i].pid = pid; //fork te devuelve el PID del hijo si estas en el padre</a>
<a name="ln195">            // Guardar un nombre amigable del jugador a partir del binario (basename)</a>
<a name="ln196">            const char *bn = player_bins[i];</a>
<a name="ln197">            const char *slash = strrchr(bn, '/');</a>
<a name="ln198">            const char *pname = slash ? slash + 1 : bn;</a>
<a name="ln199">            snprintf(gs-&gt;players[i].name, MAX_NAME_LEN, &quot;%s&quot;, pname);</a>
<a name="ln200">            writer_exit(sync);</a>
<a name="ln201">        }</a>
<a name="ln202">    }</a>
<a name="ln203"></a>
<a name="ln204">    // fork vista </a>
<a name="ln205">    pid_t view_pid = -1; // PID del proceso de la vista (si se crea)</a>
<a name="ln206">    if (view_bin){ </a>
<a name="ln207">        view_pid = fork();</a>
<a name="ln208">        if (view_pid&lt;0) </a>
<a name="ln209">            die(&quot;Error: could not fork view process&quot;, ERROR_FORK);</a>
<a name="ln210">        if (view_pid == 0){ // estamos en el hijo: la vista</a>
<a name="ln211">            exec_with_board_args(view_bin, board_width, board_height, &quot;exec view&quot;);</a>
<a name="ln212">        } </a>
<a name="ln213">    }</a>
<a name="ln214"></a>
<a name="ln215">    // habilitar primer movimiento de todos los jugadores</a>
<a name="ln216">    for (unsigned i=0; i&lt;gs-&gt;num_players; i++)</a>
<a name="ln217">        sem_post(&amp;sync-&gt;player_ready[i]);</a>
<a name="ln218"></a>
<a name="ln219">    //primer print al iniciar si hay vista </a>
<a name="ln220">    if (view_bin){ </a>
<a name="ln221">        sem_post(&amp;sync-&gt;view_ready); // A++ (le avisa a la vista que hay cambios por imprimir)</a>
<a name="ln222">        sem_wait(&amp;sync-&gt;view_done); // B-- (espera a que la vista termine de imprimir)</a>
<a name="ln223">    }</a>
<a name="ln224"></a>
<a name="ln225">    // main loop </a>
<a name="ln226">    struct timespec last_valid;  // timespec esta en &lt;time.h&gt;</a>
<a name="ln227">    clock_gettime(CLOCK_MONOTONIC, &amp;last_valid);</a>
<a name="ln228">    unsigned next_idx = 0; // próximo jugador a atender (round-robin sin sesgo)</a>
<a name="ln229"></a>
<a name="ln230">    while (1) {</a>
<a name="ln231">        // 1) Timeout global: armá timeout relativo para select</a>
<a name="ln232">        struct timespec now;</a>
<a name="ln233">        clock_gettime(CLOCK_MONOTONIC, &amp;now);</a>
<a name="ln234"></a>
<a name="ln235">        time_t elapsed = now.tv_sec - last_valid.tv_sec;</a>
<a name="ln236">        if (elapsed &gt;= timeout_s) {</a>
<a name="ln237">            writer_enter(sync);</a>
<a name="ln238">            gs-&gt;game_finished = true;</a>
<a name="ln239">            writer_exit(sync);</a>
<a name="ln240">            if (view_bin) </a>
<a name="ln241">                sem_post(&amp;sync-&gt;view_ready);</a>
<a name="ln242">            break; // salgo del bucle principal del juego</a>
<a name="ln243">        }</a>
<a name="ln244">        time_t remain = timeout_s - elapsed;</a>
<a name="ln245"></a>
<a name="ln246">        // 2) Armar fd_set con todos los jugadores NO bloqueados</a>
<a name="ln247">        fd_set rfds;</a>
<a name="ln248">        FD_ZERO(&amp;rfds);</a>
<a name="ln249">        int maxfd = -1;</a>
<a name="ln250">        unsigned active_cnt = 0;</a>
<a name="ln251"></a>
<a name="ln252">        // Tomo snapshot de bloqueados bajo lock de lector.</a>
<a name="ln253">        bool blocked[MAX_PLAYERS];</a>
<a name="ln254">        reader_enter(sync);</a>
<a name="ln255">        for (unsigned i = 0; i &lt; gs-&gt;num_players; i++)</a>
<a name="ln256">            blocked[i] = gs-&gt;players[i].is_blocked;</a>
<a name="ln257">        reader_exit(sync);</a>
<a name="ln258"></a>
<a name="ln259">        for (unsigned i = 0; i &lt; gs-&gt;num_players; i++) {</a>
<a name="ln260">            if (!blocked[i] &amp;&amp; pipes[i].read_fd &gt;= 0) {</a>
<a name="ln261">                FD_SET(pipes[i].read_fd, &amp;rfds);</a>
<a name="ln262">                if (pipes[i].read_fd &gt; maxfd) </a>
<a name="ln263">                    maxfd = pipes[i].read_fd;</a>
<a name="ln264">                active_cnt++;</a>
<a name="ln265">            }</a>
<a name="ln266">        }</a>
<a name="ln267"></a>
<a name="ln268">        // Si no queda nadie activo, terminá</a>
<a name="ln269">        if (active_cnt == 0) {</a>
<a name="ln270">            writer_enter(sync);</a>
<a name="ln271">            gs-&gt;game_finished = true;</a>
<a name="ln272">            writer_exit(sync);</a>
<a name="ln273">            if (view_bin) sem_post(&amp;sync-&gt;view_ready);</a>
<a name="ln274">            break; // TODO: modularizar esto de que termino el juego</a>
<a name="ln275">        }</a>
<a name="ln276"></a>
<a name="ln277">        // 3) Dormir hasta que alguien escriba o venza el timeout global</a>
<a name="ln278">        struct timeval tv;</a>
<a name="ln279">        tv.tv_sec  = remain;</a>
<a name="ln280">        tv.tv_usec = 0;</a>
<a name="ln281"></a>
<a name="ln282">        int ready = select(maxfd + 1, &amp;rfds, NULL, NULL, &amp;tv);</a>
<a name="ln283">        if (ready &lt; 0) {</a>
<a name="ln284">            if (errno == EINTR) continue; // reintentar si fue por señal</a>
<a name="ln285">            die(&quot;Error: select() failed while waiting for player input&quot;, ERROR_SELECT);</a>
<a name="ln286">        }</a>
<a name="ln287">        if (ready == 0) {</a>
<a name="ln288">            // venció timeout_s sin movimientos</a>
<a name="ln289">            writer_enter(sync);</a>
<a name="ln290">            gs-&gt;game_finished = true;</a>
<a name="ln291">            writer_exit(sync);</a>
<a name="ln292">            if (view_bin) sem_post(&amp;sync-&gt;view_ready);</a>
<a name="ln293">            break;</a>
<a name="ln294">        }</a>
<a name="ln295"></a>
<a name="ln296">        // 4) Hay al menos un fd listo: procesar en round-robin (1 mov por jugador listo)</a>
<a name="ln297">        // int progressed = 0;</a>
<a name="ln298">        for (unsigned step = 0; step &lt; gs-&gt;num_players; step++) {</a>
<a name="ln299">            unsigned i = (next_idx + step) % gs-&gt;num_players;</a>
<a name="ln300">            int fd = pipes[i].read_fd;</a>
<a name="ln301">            if (fd &lt; 0 || blocked[i]) continue;</a>
<a name="ln302">            if (!FD_ISSET(fd, &amp;rfds)) continue;  // no estaba listo en esta ronda</a>
<a name="ln303"></a>
<a name="ln304">            unsigned char dir;</a>
<a name="ln305">            ssize_t n = read(fd, &amp;dir, 1);</a>
<a name="ln306">            if (n == 0) {</a>
<a name="ln307">                // EOF: jugador bloqueado y saco el fd del sistema</a>
<a name="ln308">                writer_enter(sync);</a>
<a name="ln309">                gs-&gt;players[i].is_blocked = true;</a>
<a name="ln310">                writer_exit(sync);</a>
<a name="ln311">                close(fd);</a>
<a name="ln312">                pipes[i].read_fd = -1;</a>
<a name="ln313">                pipes[i].alive = 0;</a>
<a name="ln314">                continue;</a>
<a name="ln315">            } else if (n &lt; 0) {</a>
<a name="ln316">                if (errno == EAGAIN) continue;   // raro, pero posible: otro hilo drenó</a>
<a name="ln317">                // error duro: tratemos como EOF</a>
<a name="ln318">                writer_enter(sync);</a>
<a name="ln319">                gs-&gt;players[i].is_blocked = true;</a>
<a name="ln320">                writer_exit(sync);</a>
<a name="ln321">                close(fd);</a>
<a name="ln322">                pipes[i].read_fd = -1;</a>
<a name="ln323">                pipes[i].alive = 0;</a>
<a name="ln324">                continue;</a>
<a name="ln325">            }</a>
<a name="ln326"></a>
<a name="ln327">            // Aplicar exactamente UN movimiento</a>
<a name="ln328">            int was_valid;</a>
<a name="ln329">            writer_enter(sync);</a>
<a name="ln330">            was_valid = apply_move(gs, (int)i, dir);</a>
<a name="ln331">            writer_exit(sync);</a>
<a name="ln332"></a>
<a name="ln333">            if (was_valid) clock_gettime(CLOCK_MONOTONIC, &amp;last_valid);</a>
<a name="ln334"></a>
<a name="ln335">            // Notificar vista por cada movimiento</a>
<a name="ln336">            if (view_bin) {</a>
<a name="ln337">                sem_post(&amp;sync-&gt;view_ready);</a>
<a name="ln338">                sem_wait(&amp;sync-&gt;view_done);</a>
<a name="ln339">            }</a>
<a name="ln340"></a>
<a name="ln341">            // Delay por jugada</a>
<a name="ln342">            if (delay_ms &gt; 0) {</a>
<a name="ln343">                struct timespec ts = { .tv_sec = delay_ms/1000,</a>
<a name="ln344">                                    .tv_nsec = (delay_ms%1000)*1000000L };</a>
<a name="ln345">                nanosleep(&amp;ts, NULL);</a>
<a name="ln346">            }</a>
<a name="ln347"></a>
<a name="ln348">            // Habilitar próximo movimiento del mismo jugador</a>
<a name="ln349">            sem_post(&amp;sync-&gt;player_ready[i]);</a>
<a name="ln350">        }</a>
<a name="ln351"></a>
<a name="ln352">        // Avanzar el puntero de fairness</a>
<a name="ln353">        next_idx = (next_idx + 1) % gs-&gt;num_players;</a>
<a name="ln354"></a>
<a name="ln355">        // Acá NO hace falta un sleep “tiny”; select ya bloquea si nadie escribe</a>
<a name="ln356">    }</a>
<a name="ln357"></a>
<a name="ln358"></a>
<a name="ln359">    int status;</a>
<a name="ln360"></a>
<a name="ln361">    if (view_pid&gt;0) {// Si existe el proceso vista...</a>
<a name="ln362">        waitpid(view_pid,&amp;status,0); // ...espera a que termine el proceso vista</a>
<a name="ln363">        if (WIFEXITED(status)) {</a>
<a name="ln364">            printf(&quot;view exit=%d\n&quot;, WEXITSTATUS(status));</a>
<a name="ln365">        } else if (WIFSIGNALED(status)) {</a>
<a name="ln366">            printf(&quot;view signal=%d\n&quot;, WTERMSIG(status));</a>
<a name="ln367">        }</a>
<a name="ln368">    }    </a>
<a name="ln369">    </a>
<a name="ln370">    // esperar hijos y reportar puntajes (formato requerido)</a>
<a name="ln371">    for (unsigned i=0;i&lt;gs-&gt;num_players;i++){</a>
<a name="ln372">        int code = -1;</a>
<a name="ln373">        if (pipes[i].pid&gt;0) {</a>
<a name="ln374">            waitpid(pipes[i].pid,&amp;status,0); // Espera a que termine el proceso del jugador</a>
<a name="ln375">            if (WIFEXITED(status)) code = WEXITSTATUS(status);</a>
<a name="ln376">            else if (WIFSIGNALED(status)) code = WTERMSIG(status); // mostramos la señal como código</a>
<a name="ln377">        }</a>
<a name="ln378">        unsigned score, vld, inv;</a>
<a name="ln379">        char namebuf[MAX_NAME_LEN];</a>
<a name="ln380">        reader_enter(sync);</a>
<a name="ln381">        score = gs-&gt;players[i].score;</a>
<a name="ln382">        vld = gs-&gt;players[i].valid_moves;</a>
<a name="ln383">        inv = gs-&gt;players[i].invalid_moves;</a>
<a name="ln384">        snprintf(namebuf, sizeof namebuf, &quot;%s&quot;, gs-&gt;players[i].name);</a>
<a name="ln385">        reader_exit(sync);</a>
<a name="ln386"></a>
<a name="ln387">        printf(&quot;Player %s (%u) exited (%d) with a score of %u / %u / %u\n&quot;,</a>
<a name="ln388">               namebuf, i, code, score, vld, inv);</a>
<a name="ln389">        close(pipes[i].read_fd);</a>
<a name="ln390">    }</a>
<a name="ln391">    </a>
<a name="ln392"></a>
<a name="ln393">    // limpiar SHM  </a>
<a name="ln394">    game_state_unmap_destroy(game_state_shm);</a>
<a name="ln395">    game_sync_unmap_destroy(game_sync_shm);</a>
<a name="ln396">    return SUCCESS;</a>
<a name="ln397">}</a>
<a name="ln398"></a>
<a name="ln399"></a>
</code></pre>
<div class="balloon" rel="1"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v009/" target="_blank">V009</a> To use free version of PVS-Studio, source code files are required to start with a special comment.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>