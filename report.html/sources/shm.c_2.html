<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>shm.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">#define _GNU_SOURCE</a>
<a name="ln2">#include &lt;fcntl.h&gt;</a>
<a name="ln3">#include &lt;sys/mman.h&gt;</a>
<a name="ln4">#include &lt;sys/stat.h&gt;</a>
<a name="ln5">#include &lt;unistd.h&gt;</a>
<a name="ln6">#include &lt;errno.h&gt;</a>
<a name="ln7">#include &lt;stdlib.h&gt;</a>
<a name="ln8">#include &lt;string.h&gt;</a>
<a name="ln9">#include &lt;stdio.h&gt;</a>
<a name="ln10"></a>
<a name="ln11">#include &quot;common.h&quot;</a>
<a name="ln12">#include &quot;shm.h&quot;</a>
<a name="ln13"></a>
<a name="ln14">/* ------------------------------------------------------------------ */</a>
<a name="ln15">/*     Representación interna del &quot;handle&quot; a una región compartida     */</a>
<a name="ln16">/* ------------------------------------------------------------------ */</a>
<a name="ln17">struct shm_cdt {</a>
<a name="ln18">    char   *name;    // copia del nombre (para unlink)</a>
<a name="ln19">    int     fd;      // descriptor de archivo devuelto por shm_open</a>
<a name="ln20">    size_t  size;    // tamaño mapeado actual</a>
<a name="ln21">    void   *base;    // dirección base del mmap (NULL si no está mapeado)</a>
<a name="ln22">    bool    owner;   // true si este proceso la creó (O_CREAT|O_EXCL) (solo el master puede crear y eliminar, por eso necesitamos este dato)</a>
<a name="ln23">};</a>
<a name="ln24"></a>
<a name="ln25">/* ------------------------------ helpers ----------------------------- */</a>
<a name="ln26">static int ensure_size(int fd, size_t sz) { //Fijar tamaño real con ftruncate de shm</a>
<a name="ln27">    return ftruncate(fd, (off_t)sz); // 0 OK, -1 error</a>
<a name="ln28">}</a>
<a name="ln29"></a>
<a name="ln30">//Mapea la SHM con lectura/escritura y compartida entre proceso. Devuelve el puntero a la zona de memoria</a>
<a name="ln31">static void *map_rw(int fd, size_t sz) { </a>
<a name="ln32">    void *p = mmap(NULL, sz, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</a>
<a name="ln33">    return (p == MAP_FAILED) ? NULL : p; //devuelve un puntero a la memoria compartida recién mapeada. Si falla, devuelve NULL.</a>
<a name="ln34">}</a>
<a name="ln35"></a>
<a name="ln36">//Desmapea si hay algo mapeado. Útil cuando necesitamos remapear con otro tamaño.</a>
<a name="ln37">// Devuelve: 0 (ok) o -1 (error)</a>
<a name="ln38">static int unmap_if_mapped(struct shm_cdt *r) { </a>
<a name="ln39">    if (r-&gt;base &amp;&amp; r-&gt;size) { // Si hay algo mapeado...</a>
<a name="ln40">        if (munmap(r-&gt;base, r-&gt;size) == -1)  // desmapea </a>
<a name="ln41">            return -1;</a>
<a name="ln42">        r-&gt;base = NULL;</a>
<a name="ln43">    }</a>
<a name="ln44">    return 0;</a>
<a name="ln45">}</a>
<a name="ln46"></a>
<a name="ln47">// Libera todos los recursos asociados a un handle de SHM</a>
<a name="ln48">static void free_shm_handle(struct shm_cdt *r) {</a>
<a name="ln49">    if (r) {</a>
<a name="ln50">        free(r-&gt;name);</a>
<a name="ln51">        free(r);</a>
<a name="ln52">    }</a>
<a name="ln53">}</a>
<a name="ln54"></a>
<a name="ln55">static int init_game_sync_semaphores(game_sync_t *sync){</a>
<a name="ln56">    // Semáforos anónimos COMPARTIDOS ENTRE PROCESOS: pshared=1 (clave)</a>
<a name="ln57">    // A / B: master &lt;-&gt; vista</a>
<a name="ln58">    //A: “hay cambios, imprimí”.</a>
<a name="ln59">    //B: “ya imprimí”.</a>
<a name="ln60">    //Inician en 0 (cerrados).</a>
<a name="ln61">    if (sem_init(&amp;sync-&gt;view_ready, 1, 0) == -1) </a>
<a name="ln62">        return -1; // A</a>
<a name="ln63">    if (sem_init(&amp;sync-&gt;view_done, 1, 0) == -1) </a>
<a name="ln64">        return -1; // B</a>
<a name="ln65">    // Lectores / Escritor: C, D, E + F</a>
<a name="ln66">    //C/D/E + F: patrón lectores‑escritor sin inanición del escritor (lo pide el enunciado).</a>
<a name="ln67">    //reader_count arranca en 0.</a>
<a name="ln68">    //reader_count_mutex protege a F.</a>
<a name="ln69">    //state_mutex/writer_mutex los usás para que jugadores (lectores) convivan y el máster (escritor) no se quede con hambre. (La versión exacta la definís vos, pero debe prevenir inanición del escritor.)</a>
<a name="ln70">    if (sem_init(&amp;sync-&gt;writer_mutex, 1, 1) == -1) </a>
<a name="ln71">        return -1; // C</a>
<a name="ln72">    if (sem_init(&amp;sync-&gt;state_mutex, 1, 1) == -1) </a>
<a name="ln73">        return -1; // D</a>
<a name="ln74">    if (sem_init(&amp;sync-&gt;reader_count_mutex, 1, 1) == -1) </a>
<a name="ln75">        return -1; // E</a>
<a name="ln76">    sync-&gt;reader_count = 0;                                          // F</a>
<a name="ln77">    // G[i]: un semáforo por jugador, inicialmente cerrado</a>
<a name="ln78">    // G[i]: cada jugador solo puede enviar un movimiento cuando el máster lo habilita con sem_post(G[i]). Inician cerrados. Esto también está especificado en el enunciado.</a>
<a name="ln79">    // Importante: pshared = 1 en todos los sem_init porque los sem_t están en SHM y deben ser visibles entre procesos (no threads del mismo proceso).</a>
<a name="ln80">    for (int i = 0; i &lt; MAX_PLAYERS; ++i) {</a>
<a name="ln81">        if (sem_init(&amp;sync-&gt;player_ready[i], 1, 0) == -1) </a>
<a name="ln82">            return -1; // G[i]</a>
<a name="ln83">    }</a>
<a name="ln84">    return 0;</a>
<a name="ln85">}</a>
<a name="ln86"></a>
<a name="ln87">/* =================================================================== */</a>
<a name="ln88">/*                      API genérica de región SHM                      */</a>
<a name="ln89">/* =================================================================== */</a>
<a name="ln90"></a>
<a name="ln91">// Crea/abre una región de memoria compartida (SHM) y devuelve un “handle” vía *pr. Retorna 0 si salió bien, -1 si hubo error (y deja errno seteado).</a>
<a name="ln92">int shm_region_open(shm_adt *pr, const char *name, size_t size) {</a>
<a name="ln93">    if (!pr || !name || size == 0) { //Validaciones de argumentos.</a>
<a name="ln94">        errno = EINVAL; </a>
<a name="ln95">        return -1; </a>
<a name="ln96">    } </a>
<a name="ln97"></a>
<a name="ln98">    struct shm_cdt *r = calloc(1, sizeof(*r)); //Creamos el handle inicializado en 0 (owner=false, fd=0, etc).</a>
<a name="ln99">    if (!r) // Si falló la reserva, corta con error (quedará errno que haya puesto calloc).</a>
<a name="ln100">        return -1;</a>
<a name="ln101"></a>
<a name="ln102">    r-&gt;name = strdup(name); // Guardamos una copia del name (lo vamos a usar en unlink)</a>
<a name="ln103">    if (!r-&gt;name) {  //Si falla la copia del nombre, libera el handle y retorna error.</a>
<a name="ln104">        free(r); </a>
<a name="ln105">        return -1;</a>
<a name="ln106">    }</a>
<a name="ln107"></a>
<a name="ln108">    // Intento crear la shm. Si ya existe, falla con EEXIST</a>
<a name="ln109">    // Usamos permisos 0666 (respetando umask) para permitir que otros procesos/usuarios abran la SHM.</a>
<a name="ln110">    // Esto evita EACCES cuando, por ejemplo, distintos binarios/tests comparten los mismos nombres.</a>
<a name="ln111">    r-&gt;fd = shm_open(name, O_RDWR | O_CREAT | O_EXCL, 0666);</a>
<a name="ln112"></a>
<a name="ln113">    if (r-&gt;fd != -1) { // Caso 1: Si la creación salió bien, somos dueños</a>
<a name="ln114">        r-&gt;owner = true;</a>
<a name="ln115">        r-&gt;size  = size;</a>
<a name="ln116">        if (ensure_size(r-&gt;fd, size) == -1) { // Ajusta el tamaño real del objeto SHM con ftruncate (dentro de ensure_size).</a>
<a name="ln117">            int e = errno;</a>
<a name="ln118">            close(r-&gt;fd);</a>
<a name="ln119">            shm_unlink(name);</a>
<a name="ln120">            free_shm_handle(r);</a>
<a name="ln121">            errno = e;</a>
<a name="ln122">            return -1; </a>
<a name="ln123">        }</a>
<a name="ln124">        // Aseguramos permisos amplios incluso si la umask del proceso es restrictiva</a>
<a name="ln125">        (void)fchmod(r-&gt;fd, 0666);</a>
<a name="ln126">    } else if (errno == EEXIST) { // Caso 2: Si falló porque ya existía. Solo abrir</a>
<a name="ln127">        // Abrimos en RW; si el creador la dejó con permisos restrictivos podría fallar con EACCES.</a>
<a name="ln128">        // En ese caso, el caller verá errno=EACCES. Ver notas en README: limpiar SHM o alinear permisos.</a>
<a name="ln129">        r-&gt;fd = shm_open(name, O_RDWR, 0666);</a>
<a name="ln130"></a>
<a name="ln131">        if (r-&gt;fd == -1) {</a>
<a name="ln132">            int e = errno;</a>
<a name="ln133">            free_shm_handle(r);</a>
<a name="ln134">            errno = e;</a>
<a name="ln135">            return -1;</a>
<a name="ln136">        }</a>
<a name="ln137">        //Descubrimos el tamaño real existente (clave cuando no somos dueños).</a>
<a name="ln138">        //Guardamos owner=false.</a>
<a name="ln139">        struct stat st;</a>
<a name="ln140">        if (fstat(r-&gt;fd, &amp;st) == -1) {</a>
<a name="ln141">            int e = errno;</a>
<a name="ln142">            close(r-&gt;fd); </a>
<a name="ln143">            free_shm_handle(r);</a>
<a name="ln144">            errno = e;</a>
<a name="ln145">            return -1;</a>
<a name="ln146">        }</a>
<a name="ln147">        r-&gt;size  = (size_t)st.st_size; // uso el tamaño existente</a>
<a name="ln148">        r-&gt;owner = false;</a>
<a name="ln149">    } else { // Caso 3: Si falló por otro motivo, corta con error.</a>
<a name="ln150">        int e = errno;</a>
<a name="ln151">        free_shm_handle(r);</a>
<a name="ln152">        errno = e;</a>
<a name="ln153">        return -1;</a>
<a name="ln154">    }</a>
<a name="ln155"></a>
<a name="ln156">    //Dejamos sin mapear por ahora (se mapea en las funciones game_state_map y game_sync_map, porque cada una sabe qué tamaño y que struct necesita).</a>
<a name="ln157">    r-&gt;base = NULL;</a>
<a name="ln158">    *pr = r;</a>
<a name="ln159">    return 0;</a>
<a name="ln160">}</a>
<a name="ln161"></a>
<a name="ln162">//Cierra la región (para procesos que no son dueños o cuando no queremos destruirla).</a>
<a name="ln163">//Desmapea si hacía falta, cierra el fd y libera el handle.</a>
<a name="ln164">int shm_region_close(shm_adt r_) {</a>
<a name="ln165">    if (!r_) { </a>
<a name="ln166">        errno = EINVAL; </a>
<a name="ln167">        return -1; </a>
<a name="ln168">    }</a>
<a name="ln169">    struct shm_cdt *r = (struct shm_cdt*)r_; // AZU: NO ENTIENDO POR QUÉ SE HACE ESTO</a>
<a name="ln170"></a>
<a name="ln171">    int rc = 0;</a>
<a name="ln172">    if (unmap_if_mapped(r) == -1) </a>
<a name="ln173">        rc = -1;</a>
<a name="ln174">    if (close(r-&gt;fd) == -1) </a>
<a name="ln175">        rc = -1;</a>
<a name="ln176"></a>
<a name="ln177">    free_shm_handle(r);</a>
<a name="ln178">    return rc;</a>
<a name="ln179">}</a>
<a name="ln180"></a>
<a name="ln181">//Hace shm_unlink solo si este proceso fue el creador.</a>
<a name="ln182">//Ojo: unlink no desmapea ni cierra; por eso existe además *_unmap_destroy.</a>
<a name="ln183">int shm_region_unlink_if_owner(shm_adt r_) {</a>
<a name="ln184">    if (!r_) { </a>
<a name="ln185">        errno = EINVAL; </a>
<a name="ln186">        return -1; </a>
<a name="ln187">    }</a>
<a name="ln188">    struct shm_cdt *r = (struct shm_cdt*)r_;</a>
<a name="ln189">    if (!r-&gt;owner) </a>
<a name="ln190">        return 0;</a>
<a name="ln191">    return shm_unlink(r-&gt;name);</a>
<a name="ln192">}</a>
<a name="ln193"></a>
<a name="ln194">/* =================================================================== */</a>
<a name="ln195">/*                Mapeos específicos del estado y la sync               */</a>
<a name="ln196">/* =================================================================== */</a>
<a name="ln197">//Calcula el tamaño requerido incluyendo el array flexible board[].</a>
<a name="ln198">int game_state_map(shm_adt r_, unsigned short w, unsigned short h, game_state_t **out) {</a>
<a name="ln199">    if (!r_ || !out || w == 0 || h == 0) { </a>
<a name="ln200">        errno = EINVAL; </a>
<a name="ln201">        return -1; </a>
<a name="ln202">    }</a>
<a name="ln203">    struct shm_cdt *r = (struct shm_cdt*)r_;</a>
<a name="ln204"></a>
<a name="ln205">    size_t need = game_state_size(w, h); // sizeof(game_state_t) + w*h*sizeof(int)</a>
<a name="ln206"></a>
<a name="ln207">    // Si soy owner y no alcanza el tamaño actual, lo agrando</a>
<a name="ln208">    //Si no somos dueños y el tamaño existente es menor al que pedimos, error (la región creada por el máster no coincide con w*h).</a>
<a name="ln209">    if (r-&gt;owner &amp;&amp; r-&gt;size &lt; need) {</a>
<a name="ln210">        if (ensure_size(r-&gt;fd, need) == -1) </a>
<a name="ln211">            return -1;</a>
<a name="ln212">        r-&gt;size = need;</a>
<a name="ln213">    }</a>
<a name="ln214"></a>
<a name="ln215">    // (Re)mapear si hace falta</a>
<a name="ln216">    if (!r-&gt;base || r-&gt;size &lt; need) {</a>
<a name="ln217">        if (unmap_if_mapped(r) == -1) </a>
<a name="ln218">            return -1;</a>
<a name="ln219">        if (!r-&gt;owner &amp;&amp; r-&gt;size &lt; need) { </a>
<a name="ln220">            errno = EINVAL; </a>
<a name="ln221">            return -1; </a>
<a name="ln222">        } // región muy chica</a>
<a name="ln223">        r-&gt;base = map_rw(r-&gt;fd, r-&gt;size);</a>
<a name="ln224">        if (!r-&gt;base) </a>
<a name="ln225">            return -1;</a>
<a name="ln226">    }</a>
<a name="ln227"></a>
<a name="ln228">    //Si somos dueños, inicializamos todo en cero (incluido board) y seteamos dimensiones.</a>
<a name="ln229">    //El llenado con recompensas 1..9 se hace después, por la lógica del máster (para poder usar la seed). (El enunciado fija 1..9 para celdas libres).</a>
<a name="ln230">    game_state_t *gs = (game_state_t*)r-&gt;base;</a>
<a name="ln231">    *out = gs;</a>
<a name="ln232"></a>
<a name="ln233">    if (r-&gt;owner) {</a>
<a name="ln234">        // Inicialización mínima segura. Llenar el board con 1..9 lo hace el máster luego.</a>
<a name="ln235">        memset(gs, 0, r-&gt;size);</a>
<a name="ln236">        gs-&gt;board_width   = w;</a>
<a name="ln237">        gs-&gt;board_height  = h;</a>
<a name="ln238">        gs-&gt;num_players   = 0;</a>
<a name="ln239">        gs-&gt;game_finished = false;</a>
<a name="ln240">    }</a>
<a name="ln241">    return 0;</a>
<a name="ln242">}</a>
<a name="ln243"></a>
<a name="ln244">///game_sync siempre vale sizeof(game_sync_t) (no hay array flexible).</a>
<a name="ln245">int game_sync_map(shm_adt r_, game_sync_t **out) {</a>
<a name="ln246">    if (!r_ || !out) { </a>
<a name="ln247">        errno = EINVAL; </a>
<a name="ln248">        return -1; </a>
<a name="ln249">    }</a>
<a name="ln250">    struct shm_cdt *r = (struct shm_cdt*)r_;</a>
<a name="ln251"></a>
<a name="ln252">    size_t need = sizeof(game_sync_t);</a>
<a name="ln253"></a>
<a name="ln254">    if (r-&gt;owner &amp;&amp; r-&gt;size &lt; need) {</a>
<a name="ln255">        if (ensure_size(r-&gt;fd, need) == -1) </a>
<a name="ln256">            return -1;</a>
<a name="ln257">        r-&gt;size = need;</a>
<a name="ln258">    }</a>
<a name="ln259"></a>
<a name="ln260">    //Mapeo normal (mismo patrón que game_state_map).</a>
<a name="ln261">    if (!r-&gt;base || r-&gt;size &lt; need) {</a>
<a name="ln262">        if (unmap_if_mapped(r) == -1) </a>
<a name="ln263">            return -1;</a>
<a name="ln264">        if (!r-&gt;owner &amp;&amp; r-&gt;size &lt; need) { </a>
<a name="ln265">            errno = EINVAL; </a>
<a name="ln266">            return -1; </a>
<a name="ln267">        }</a>
<a name="ln268">        r-&gt;base = map_rw(r-&gt;fd, r-&gt;size);</a>
<a name="ln269">        if (!r-&gt;base) </a>
<a name="ln270">            return -1;</a>
<a name="ln271">    }</a>
<a name="ln272"></a>
<a name="ln273">    game_sync_t *sync = (game_sync_t*)r-&gt;base;</a>
<a name="ln274">    *out = sync;</a>
<a name="ln275"></a>
<a name="ln276">    if (r-&gt;owner) {</a>
<a name="ln277">        if (init_game_sync_semaphores(sync) == -1)</a>
<a name="ln278">            return -1;</a>
<a name="ln279">    }</a>
<a name="ln280"></a>
<a name="ln281">    return 0;</a>
<a name="ln282">}</a>
<a name="ln283"></a>
<a name="ln284">/* =================================================================== */</a>
<a name="ln285">/*               Helpers &quot;todo en uno&quot; de destrucción final            */</a>
<a name="ln286">/* =================================================================== */</a>
<a name="ln287">//Para /game_state no hay semáforos: solo desmapeamos, cerramos y (si corresponde) unlink</a>
<a name="ln288">int game_state_unmap_destroy(shm_adt r_) {</a>
<a name="ln289">    if (!r_) { </a>
<a name="ln290">        errno = EINVAL; </a>
<a name="ln291">        return -1; </a>
<a name="ln292">    }</a>
<a name="ln293">    struct shm_cdt *r = (struct shm_cdt*)r_;</a>
<a name="ln294">    int rc = 0;</a>
<a name="ln295"></a>
<a name="ln296">    if (unmap_if_mapped(r) == -1) </a>
<a name="ln297">        rc = -1;</a>
<a name="ln298">    if (close(r-&gt;fd) == -1) </a>
<a name="ln299">        rc = -1;</a>
<a name="ln300">    if (r-&gt;owner &amp;&amp; shm_unlink(r-&gt;name) == -1) </a>
<a name="ln301">        rc = -1;</a>
<a name="ln302">    free_shm_handle(r);</a>
<a name="ln303">    return rc;</a>
<a name="ln304">}</a>
<a name="ln305"></a>
<a name="ln306">//Orden correcto cuando hay semáforos en SHM:</a>
<a name="ln307">//1.sem_destroy (mientras la memoria está mapeada),</a>
<a name="ln308">//2.munmap,</a>
<a name="ln309">//3.close,</a>
<a name="ln310">//4.shm_unlink (solo el dueño).</a>
<a name="ln311">//Esto evita leaks y cumple con la limpieza de recursos que piden.</a>
<a name="ln312">int game_sync_unmap_destroy(shm_adt r_) {</a>
<a name="ln313">    if (!r_) { </a>
<a name="ln314">        errno = EINVAL; </a>
<a name="ln315">        return -1; </a>
<a name="ln316">    }</a>
<a name="ln317">    struct shm_cdt *r = (struct shm_cdt*)r_;</a>
<a name="ln318">    int rc = 0;</a>
<a name="ln319"></a>
<a name="ln320">    // Sólo el creador destruye semáforos (orden: destruir -&gt; unmap -&gt; close -&gt; unlink)</a>
<a name="ln321">    if (r-&gt;owner &amp;&amp; r-&gt;base) {</a>
<a name="ln322">        game_sync_t *sync = (game_sync_t*)r-&gt;base;</a>
<a name="ln323">        int e = 0;</a>
<a name="ln324">        e |= sem_destroy(&amp;sync-&gt;view_ready);</a>
<a name="ln325">        e |= sem_destroy(&amp;sync-&gt;view_done);</a>
<a name="ln326">        e |= sem_destroy(&amp;sync-&gt;writer_mutex);</a>
<a name="ln327">        e |= sem_destroy(&amp;sync-&gt;state_mutex);</a>
<a name="ln328">        e |= sem_destroy(&amp;sync-&gt;reader_count_mutex);</a>
<a name="ln329">        for (int i = 0; i &lt; MAX_PLAYERS; ++i) </a>
<a name="ln330">            e |= sem_destroy(&amp;sync-&gt;player_ready[i]);</a>
<a name="ln331">        if (e == -1) </a>
<a name="ln332">            rc = -1;</a>
<a name="ln333">    }</a>
<a name="ln334"></a>
<a name="ln335">    if (unmap_if_mapped(r) == -1) </a>
<a name="ln336">        rc = -1;</a>
<a name="ln337">    if (close(r-&gt;fd) == -1) </a>
<a name="ln338">        rc = -1;</a>
<a name="ln339">    if (r-&gt;owner &amp;&amp; shm_unlink(r-&gt;name) == -1) </a>
<a name="ln340">        rc = -1;</a>
<a name="ln341"></a>
<a name="ln342">    free_shm_handle(r);</a>
<a name="ln343">    return rc;</a>
<a name="ln344">}</a>
</code></pre>
<div class="balloon" rel="1"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v009/" target="_blank">V009</a> To use free version of PVS-Studio, source code files are required to start with a special comment.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>