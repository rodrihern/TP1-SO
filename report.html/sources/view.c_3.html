<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>view.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// Vista ncurses a color con tablero fijo</a>
<a name="ln2">#define _POSIX_C_SOURCE 200809L</a>
<a name="ln3">#include &lt;stdlib.h&gt;</a>
<a name="ln4">#include &lt;unistd.h&gt;</a>
<a name="ln5">#include &lt;fcntl.h&gt;</a>
<a name="ln6">#include &lt;sys/mman.h&gt;</a>
<a name="ln7">#include &lt;sys/stat.h&gt;</a>
<a name="ln8">#include &lt;ncurses.h&gt;</a>
<a name="ln9"></a>
<a name="ln10">#include &quot;common.h&quot;</a>
<a name="ln11">#include &quot;shm.h&quot;</a>
<a name="ln12">#include &quot;reader_sync.h&quot;</a>
<a name="ln13"></a>
<a name="ln14">// Pares de color</a>
<a name="ln15">#define C_DEFAULT 1</a>
<a name="ln16">#define C_PLAYER_BASE 2</a>
<a name="ln17"></a>
<a name="ln18">static void ui_init(void){</a>
<a name="ln19">    if (getenv(&quot;TERM&quot;) == NULL) { </a>
<a name="ln20">        setenv(&quot;TERM&quot;, &quot;xterm-256color&quot;, 1); // para que corra con el master de la catedra</a>
<a name="ln21">    }</a>
<a name="ln22">    initscr();</a>
<a name="ln23">    cbreak();</a>
<a name="ln24">    noecho();</a>
<a name="ln25">    curs_set(0);</a>
<a name="ln26">    nodelay(stdscr, TRUE); // no bloquear en getch</a>
<a name="ln27">    keypad(stdscr, TRUE);</a>
<a name="ln28">    if (has_colors()){</a>
<a name="ln29">        start_color();</a>
<a name="ln30">        use_default_colors();</a>
<a name="ln31">        init_pair(C_DEFAULT, COLOR_WHITE, -1);</a>
<a name="ln32">        // Colores por jugador (fg,bg) según pedido: </a>
<a name="ln33">        init_pair(C_PLAYER_BASE + 0, COLOR_RED, -1);</a>
<a name="ln34">        init_pair(C_PLAYER_BASE + 1, COLOR_GREEN, -1);</a>
<a name="ln35">        init_pair(C_PLAYER_BASE + 2, COLOR_BLUE, -1);</a>
<a name="ln36">        init_pair(C_PLAYER_BASE + 3, COLOR_MAGENTA, -1);</a>
<a name="ln37">        init_pair(C_PLAYER_BASE + 4, COLOR_YELLOW, -1);</a>
<a name="ln38">        init_pair(C_PLAYER_BASE + 5, COLOR_CYAN, -1);</a>
<a name="ln39">        init_pair(C_PLAYER_BASE + 6, COLOR_BLACK, -1);</a>
<a name="ln40">        init_pair(C_PLAYER_BASE + 7, COLOR_YELLOW, COLOR_BLUE);</a>
<a name="ln41">        init_pair(C_PLAYER_BASE + 8, COLOR_RED, COLOR_WHITE);</a>
<a name="ln42">    }</a>
<a name="ln43">}</a>
<a name="ln44"></a>
<a name="ln45">static void ui_end(void){</a>
<a name="ln46">    nodelay(stdscr, FALSE);</a>
<a name="ln47">    endwin();</a>
<a name="ln48">}</a>
<a name="ln49"></a>
<a name="ln50">// Ya no coloreamos las recompensas: se imprimen en color por defecto</a>
<a name="ln51"></a>
<a name="ln52">static short color_for_player(unsigned id){</a>
<a name="ln53">    return C_PLAYER_BASE + (id % 9);</a>
<a name="ln54">}</a>
<a name="ln55"></a>
<a name="ln56">static void draw_header(const game_state_t *gs){</a>
<a name="ln57">    attron(A_BOLD);</a>
<a name="ln58">    mvprintw(0, 0, &quot;ChompChamps %ux%u  players=%u  finished=%d&quot;,</a>
<a name="ln59">             gs-&gt;board_width, gs-&gt;board_height, gs-&gt;num_players, gs-&gt;game_finished);</a>
<a name="ln60">    attroff(A_BOLD);</a>
<a name="ln61">}</a>
<a name="ln62"></a>
<a name="ln63">static int draw_players(const game_state_t *gs, int start_row){</a>
<a name="ln64">    mvprintw(start_row, 0, &quot;Players:&quot;);</a>
<a name="ln65">    int row = start_row + 1;</a>
<a name="ln66">    for (unsigned i = 0; i &lt; gs-&gt;num_players; ++i){</a>
<a name="ln67">        const player_t *p = &amp;gs-&gt;players[i];</a>
<a name="ln68">        short pc = color_for_player(i);</a>
<a name="ln69">        attron(COLOR_PAIR(pc));</a>
<a name="ln70">        mvprintw(row++, 0, &quot;P%u %s  pos=(%u,%u)  score=%u  V=%u  I=%u&quot;,</a>
<a name="ln71">                 i, p-&gt;is_blocked?&quot; [BLOCKED]&quot;:&quot;&quot;,</a>
<a name="ln72">                 p-&gt;x, p-&gt;y, p-&gt;score, p-&gt;valid_moves, p-&gt;invalid_moves);</a>
<a name="ln73">        attroff(COLOR_PAIR(pc));</a>
<a name="ln74">    }</a>
<a name="ln75">    return row; // próxima fila libre</a>
<a name="ln76">}</a>
<a name="ln77"></a>
<a name="ln78">static void draw_board_centered(const game_state_t *gs, int reserve_top_rows){</a>
<a name="ln79">    int maxy, maxx; </a>
<a name="ln80">    getmaxyx(stdscr, maxy, maxx);</a>
<a name="ln81">    const int cellw = 4; // ancho por celda: suficiente para &quot;p[8]&quot; o &quot;%3d&quot;</a>
<a name="ln82"></a>
<a name="ln83">    int bw = gs-&gt;board_width, bh = gs-&gt;board_height;</a>
<a name="ln84">    int draw_h = bh;</a>
<a name="ln85">    int draw_w = bw;</a>
<a name="ln86">    // Limitar por tamaño de terminal</a>
<a name="ln87">    if (draw_h &gt; maxy - 2) draw_h = maxy - 2; // deja margen</a>
<a name="ln88">    if (draw_w * cellw &gt; maxx - 2) draw_w = (maxx - 2) / cellw;</a>
<a name="ln89">    if (draw_h &lt;= 0 || draw_w &lt;= 0) return;</a>
<a name="ln90"></a>
<a name="ln91">    // Centro ideal</a>
<a name="ln92">    int row0 = (maxy - draw_h) / 2;</a>
<a name="ln93">    int col0 = (maxx - draw_w * cellw) / 2;</a>
<a name="ln94">    // Evitar superponerse con header/lista de jugadores</a>
<a name="ln95">    if (row0 &lt;= reserve_top_rows) row0 = reserve_top_rows + 1;</a>
<a name="ln96">    if (col0 &lt; 0) col0 = 0;</a>
<a name="ln97"></a>
<a name="ln98">    // mvprintw(row0 - 1, col0, &quot;Board (%dx%d shown of %dx%d):&quot;, draw_w, draw_h, bw, bh);</a>
<a name="ln99"></a>
<a name="ln100">    for (int y = 0; y &lt; draw_h; ++y){</a>
<a name="ln101">        int sy = row0 + y; if (sy &gt;= maxy) break;</a>
<a name="ln102">        for (int x = 0; x &lt; draw_w; ++x){</a>
<a name="ln103">            int sx = col0 + x * cellw; if (sx + (cellw-1) &gt;= maxx) break;</a>
<a name="ln104"></a>
<a name="ln105">            // ¿Hay un jugador parado en (x,y)?</a>
<a name="ln106">            int standing_pid = -1;</a>
<a name="ln107">            for (unsigned i = 0; i &lt; gs-&gt;num_players; ++i){</a>
<a name="ln108">                const player_t *p = &amp;gs-&gt;players[i];</a>
<a name="ln109">                if ((int)p-&gt;x == x &amp;&amp; (int)p-&gt;y == y){ standing_pid = (int)i; break; }</a>
<a name="ln110">            }</a>
<a name="ln111"></a>
<a name="ln112">            if (standing_pid &gt;= 0){</a>
<a name="ln113">                short pc = color_for_player((unsigned)standing_pid);</a>
<a name="ln114">                attron(COLOR_PAIR(pc) | A_BOLD);</a>
<a name="ln115">                // p[id] con ancho 4 (ej: p[8] )</a>
<a name="ln116">                mvprintw(sy, sx, &quot;p[%d]&quot;, standing_pid);</a>
<a name="ln117">                attroff(COLOR_PAIR(pc) | A_BOLD);</a>
<a name="ln118">                continue;</a>
<a name="ln119">            }</a>
<a name="ln120"></a>
<a name="ln121">            int v = gs-&gt;board[idx(x, y, bw)];</a>
<a name="ln122">            if (v &gt; 0){</a>
<a name="ln123">                // Recompensas sin color especial</a>
<a name="ln124">                attron(COLOR_PAIR(C_DEFAULT));</a>
<a name="ln125">                mvprintw(sy, sx, &quot;%3d &quot;, v);</a>
<a name="ln126">                attroff(COLOR_PAIR(C_DEFAULT));</a>
<a name="ln127">            } else {</a>
<a name="ln128">                // 0 o negativo: se imprime el número tal cual, coloreado por jugador</a>
<a name="ln129">                unsigned pid = (unsigned)(-v);</a>
<a name="ln130">                short pc = color_for_player(pid);</a>
<a name="ln131">                attron(COLOR_PAIR(pc) | A_BOLD);</a>
<a name="ln132">                mvprintw(sy, sx, &quot;%3d &quot;, v);</a>
<a name="ln133">                attroff(COLOR_PAIR(pc) | A_BOLD);</a>
<a name="ln134">            }</a>
<a name="ln135">        }</a>
<a name="ln136">    }</a>
<a name="ln137">}</a>
<a name="ln138"></a>
<a name="ln139">int main(int argc, char **argv){</a>
<a name="ln140">    if (argc&lt;3){ </a>
<a name="ln141">        fprintf(stderr,&quot;uso: vista &lt;W&gt; &lt;H&gt;\n&quot;); </a>
<a name="ln142">        return ERROR_INVALID_ARGS; </a>
<a name="ln143">    }</a>
<a name="ln144">    int W = atoi(argv[1]), H = atoi(argv[2]);</a>
<a name="ln145"></a>
<a name="ln146">    shm_adt state_h, sync_h;</a>
<a name="ln147">    if (shm_region_open(&amp;state_h, SHM_STATE, game_state_size(W,H)) == -1) { </a>
<a name="ln148">        perror(&quot;state open&quot;); </a>
<a name="ln149">        return ERROR_SHM_ATTACH; </a>
<a name="ln150">    }</a>
<a name="ln151">    if (shm_region_open(&amp;sync_h, SHM_SYNC, sizeof(game_sync_t)) == -1) { </a>
<a name="ln152">        perror(&quot;sync open&quot;);  </a>
<a name="ln153">        return ERROR_SHM_ATTACH; </a>
<a name="ln154">    }</a>
<a name="ln155"></a>
<a name="ln156">    game_state_t *gs=NULL; game_sync_t *sync=NULL;</a>
<a name="ln157">    if (game_state_map(state_h, (unsigned short)W, (unsigned short)H, &amp;gs) == -1) { </a>
<a name="ln158">        perror(&quot;map state&quot;); </a>
<a name="ln159">        return ERROR_SHM_ATTACH; </a>
<a name="ln160">    }</a>
<a name="ln161">    if (game_sync_map(sync_h, &amp;sync) == -1) { </a>
<a name="ln162">        perror(&quot;map sync&quot;); </a>
<a name="ln163">        return ERROR_SHM_ATTACH; </a>
<a name="ln164">    }</a>
<a name="ln165"></a>
<a name="ln166">    ui_init();</a>
<a name="ln167">    while (1){</a>
<a name="ln168">        sem_wait(&amp;sync-&gt;view_ready);</a>
<a name="ln169">        reader_enter(sync);</a>
<a name="ln170">        int finished = gs-&gt;game_finished;</a>
<a name="ln171"></a>
<a name="ln172">        erase();</a>
<a name="ln173">        draw_header(gs);</a>
<a name="ln174">    int next_row = draw_players(gs, 2);</a>
<a name="ln175">    draw_board_centered(gs, next_row + 1);</a>
<a name="ln176">        refresh();</a>
<a name="ln177"></a>
<a name="ln178">        reader_exit(sync);</a>
<a name="ln179">        sem_post(&amp;sync-&gt;view_done);</a>
<a name="ln180"></a>
<a name="ln181">    // Ignorar input: no permitir salir con 'q'</a>
<a name="ln182">    (void)getch();</a>
<a name="ln183">        if (finished) break;</a>
<a name="ln184">    }</a>
<a name="ln185"></a>
<a name="ln186">    ui_end();</a>
<a name="ln187"></a>
<a name="ln188">    game_state_unmap_destroy(state_h);</a>
<a name="ln189">    game_sync_unmap_destroy(sync_h);</a>
<a name="ln190">    return SUCCESS;</a>
<a name="ln191">}</a>
</code></pre>
<div class="balloon" rel="1"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v009/" target="_blank">V009</a> To use free version of PVS-Studio, source code files are required to start with a special comment.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>